<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>내 위치 조회하기</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/site.css') }}" />
  </head>
  <body class="page">
    <header class="banner banner--accent">
      <p class="badge">LIVE</p>
      <h1>실시간 위치 조회 중</h1>
      <p>공유된 위치를 실시간으로 조회합니다. 상대방이 페이지를 닫아도 서버에 저장된 위치를 계속 조회합니다.</p>
    </header>

    <main class="card card--mobile">
      <section class="phone-column" hidden>
        {% include "_phone_preview.html" %}
      </section>
      <section class="status">
        <div class="status-chip">토큰 {{ token }}</div>
        <p id="status-text" class="status__text">위치 정보 조회 중...</p>
        <dl class="location-grid" id="location-grid" hidden>
          <div>
            <dt>위도</dt>
            <dd id="lat-value">-</dd>
          </div>
          <div>
            <dt>경도</dt>
            <dd id="lng-value">-</dd>
          </div>
          <div>
            <dt>정확도</dt>
            <dd id="accuracy-value">-</dd>
          </div>
          <div>
            <dt>방향</dt>
            <dd id="heading-value">-</dd>
          </div>
          <div>
            <dt>속도</dt>
            <dd id="speed-value">-</dd>
          </div>
          <div>
            <dt>마지막 업데이트</dt>
            <dd id="timestamp-value">-</dd>
          </div>
        </dl>
        <button id="stop-btn" class="btn btn-primary">조회 중지</button>
      </section>
    </main>

    <script>
      const token = '{{ token }}';
      const statusText = document.getElementById('status-text');
      const grid = document.getElementById('location-grid');
      const latEl = document.getElementById('lat-value');
      const lngEl = document.getElementById('lng-value');
      const accEl = document.getElementById('accuracy-value');
      const headingEl = document.getElementById('heading-value');
      const speedEl = document.getElementById('speed-value');
      const tsEl = document.getElementById('timestamp-value');
      const stopBtn = document.getElementById('stop-btn');

      let pollInterval = null;
      let isPolling = false;
      let lastUpdateTime = null;

      // 서버에서 최신 위치 정보를 가져오는 함수
      async function fetchLatestLocation() {
        try {
          const response = await fetch(`/api/location/${token}`);
          const data = await response.json();
          
          if (data.available && data.location) {
            const loc = data.location;
            
            // 위치 정보가 업데이트되었는지 확인
            const currentUpdateTime = loc.captured_at;
            if (currentUpdateTime !== lastUpdateTime) {
              lastUpdateTime = currentUpdateTime;
              
              statusText.textContent = '위치 정보 수신 중...';
              grid.hidden = false;
              latEl.textContent = parseFloat(loc.lat).toFixed(6);
              lngEl.textContent = parseFloat(loc.lng).toFixed(6);
              accEl.textContent = loc.accuracy ? `${parseFloat(loc.accuracy).toFixed(0)} m` : '알 수 없음';
              
              // 방향 정보 표시
              if (loc.heading !== null && loc.heading !== undefined) {
                headingEl.textContent = `${parseFloat(loc.heading).toFixed(1)}°`;
              } else {
                headingEl.textContent = '알 수 없음';
              }
              
              // 속도 정보 표시 (m/s를 km/h로 변환)
              if (loc.speed !== null && loc.speed !== undefined) {
                const speedKmh = parseFloat(loc.speed) * 3.6;
                speedEl.textContent = `${speedKmh.toFixed(1)} km/h`;
              } else {
                speedEl.textContent = '알 수 없음';
              }
              
              // 마지막 업데이트 시간 표시
              if (loc.captured_at) {
                const date = new Date(loc.captured_at);
                const now = new Date();
                const diffSeconds = Math.floor((now - date) / 1000);
                
                if (diffSeconds < 60) {
                  tsEl.textContent = `방금 전 (${date.toLocaleString('ko-KR')})`;
                } else if (diffSeconds < 3600) {
                  const minutes = Math.floor(diffSeconds / 60);
                  tsEl.textContent = `${minutes}분 전 (${date.toLocaleString('ko-KR')})`;
                } else {
                  tsEl.textContent = date.toLocaleString('ko-KR');
                }
              } else {
                tsEl.textContent = '-';
              }
            } else {
              // 위치 정보는 있지만 업데이트되지 않음 (이미 표시된 정보)
              statusText.textContent = '위치 정보 조회 중... (변경 없음)';
            }
          } else {
            statusText.textContent = '위치 정보를 기다리는 중... (상대방이 위치를 공유하면 표시됩니다)';
            grid.hidden = true;
          }
        } catch (error) {
          console.error('위치 조회 오류:', error);
          statusText.textContent = '위치 조회 중 오류가 발생했습니다. 다시 시도 중...';
          // 오류 발생 시 5초 후 다시 시도
          setTimeout(fetchLatestLocation, 5000);
        }
      }

      // 주기적으로 위치 정보 조회 시작
      function startPolling() {
        if (isPolling) return;
        isPolling = true;
        statusText.textContent = '위치 정보 조회 시작...';
        
        // 즉시 한 번 조회
        fetchLatestLocation();
        
        // 이후 2초마다 조회 (실시간에 가깝게)
        // 상대방이 페이지를 닫아도 서버에 저장된 위치를 계속 조회합니다
        pollInterval = setInterval(fetchLatestLocation, 2000);
      }

      // 조회 중지
      function stopPolling() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        isPolling = false;
        statusText.textContent = '조회를 중지했습니다.';
        grid.hidden = true;
        latEl.textContent = '-';
        lngEl.textContent = '-';
        accEl.textContent = '-';
        headingEl.textContent = '-';
        speedEl.textContent = '-';
        tsEl.textContent = '-';
        stopBtn.disabled = true;
      }

      // 페이지 로드 시 자동으로 조회 시작
      startPolling();

      // 중지 버튼 클릭 이벤트
      stopBtn.addEventListener('click', () => {
        stopPolling();
      });

      // 페이지가 백그라운드에 있어도 계속 조회하도록 유지
      // 브라우저가 백그라운드에서도 타이머를 실행할 수 있도록 함
      // (일부 브라우저는 성능을 위해 백그라운드 탭의 타이머를 느리게 실행할 수 있음)
      
      // 페이지 포커스 이벤트로 백그라운드/포그라운드 전환 감지
      window.addEventListener('focus', () => {
        // 페이지가 다시 포커스를 받으면 즉시 조회
        if (isPolling) {
          fetchLatestLocation();
        }
      });

      // 페이지 언로드 전 정리
      window.addEventListener('beforeunload', () => {
        if (pollInterval) {
          clearInterval(pollInterval);
        }
      });
    </script>
  </body>
</html>
