<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>내 위치 조회하기</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/site.css') }}" />
  </head>
  <body class="page">
    <header class="banner banner--accent">
      <p class="badge">LIVE</p>
      <h1>실시간 위치 조회 중</h1>
      <p>공유된 위치를 실시간으로 조회합니다.</p>
    </header>

    <main class="card card--mobile">
      <section class="phone-column">
        {% include "_phone_preview.html" %}
      </section>
      <section class="status">
        <div class="status-chip">토큰 {{ token }}</div>
        <p id="status-text" class="status__text">대기 중...</p>
        <dl class="location-grid" id="location-grid" hidden>
          <div>
            <dt>위도</dt>
            <dd id="lat-value">-</dd>
          </div>
          <div>
            <dt>경도</dt>
            <dd id="lng-value">-</dd>
          </div>
          <div>
            <dt>정확도</dt>
            <dd id="accuracy-value">-</dd>
          </div>
          <div>
            <dt>업데이트</dt>
            <dd id="timestamp-value">-</dd>
          </div>
        </dl>
        <button id="stop-btn" class="btn btn-primary">조회 중지</button>
      </section>
    </main>

    <script>
      const token = '{{ token }}';
      const statusText = document.getElementById('status-text');
      const grid = document.getElementById('location-grid');
      const latEl = document.getElementById('lat-value');
      const lngEl = document.getElementById('lng-value');
      const accEl = document.getElementById('accuracy-value');
      const tsEl = document.getElementById('timestamp-value');
      const stopBtn = document.getElementById('stop-btn');

      let pollInterval = null;
      let isPolling = false;

      // 서버에서 최신 위치 정보를 가져오는 함수
      async function fetchLatestLocation() {
        try {
          const response = await fetch(`/api/location/${token}`);
          const data = await response.json();
          
          if (data.available && data.location) {
            const loc = data.location;
            statusText.textContent = '위치 정보 수신 중...';
            grid.hidden = false;
            latEl.textContent = parseFloat(loc.lat).toFixed(6);
            lngEl.textContent = parseFloat(loc.lng).toFixed(6);
            accEl.textContent = loc.accuracy ? `${parseFloat(loc.accuracy).toFixed(0)} m` : '알 수 없음';
            
            if (loc.captured_at) {
              const date = new Date(loc.captured_at);
              tsEl.textContent = date.toLocaleString('ko-KR');
            } else {
              tsEl.textContent = '-';
            }
          } else {
            statusText.textContent = '위치 정보를 기다리는 중...';
            grid.hidden = true;
          }
        } catch (error) {
          console.error('위치 조회 오류:', error);
          statusText.textContent = '위치 조회 중 오류가 발생했습니다.';
        }
      }

      // 주기적으로 위치 정보 조회 시작
      function startPolling() {
        if (isPolling) return;
        isPolling = true;
        statusText.textContent = '위치 정보 조회 시작...';
        
        // 즉시 한 번 조회
        fetchLatestLocation();
        
        // 이후 2초마다 조회 (실시간에 가깝게)
        pollInterval = setInterval(fetchLatestLocation, 2000);
      }

      // 조회 중지
      function stopPolling() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        isPolling = false;
        statusText.textContent = '조회를 중지했습니다.';
        grid.hidden = true;
        latEl.textContent = '-';
        lngEl.textContent = '-';
        accEl.textContent = '-';
        tsEl.textContent = '-';
        stopBtn.disabled = true;
      }

      // 페이지 로드 시 자동으로 조회 시작
      startPolling();

      // 중지 버튼 클릭 이벤트
      stopBtn.addEventListener('click', () => {
        stopPolling();
      });

      // 페이지가 백그라운드에 있어도 계속 조회하도록 유지
      // 브라우저가 백그라운드에서도 타이머를 실행할 수 있도록 함
      // (일부 브라우저는 성능을 위해 백그라운드 탭의 타이머를 느리게 실행할 수 있음)
      
      // 페이지 포커스 이벤트로 백그라운드/포그라운드 전환 감지
      window.addEventListener('focus', () => {
        // 페이지가 다시 포커스를 받으면 즉시 조회
        if (isPolling) {
          fetchLatestLocation();
        }
      });

      // 페이지 언로드 전 정리
      window.addEventListener('beforeunload', () => {
        if (pollInterval) {
          clearInterval(pollInterval);
        }
      });
    </script>
  </body>
</html>
