<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>내 위치 공유하기</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/site.css') }}" />
  </head>
  <body class="page">
    <header class="banner banner--accent">
      <p class="badge">LIVE</p>
      <!--<h1>실시간 위치 공유 중</h1>
      <p>이 페이지를 닫으면 공유가 중단됩니다.</p>-->
    </header>

    <main class="card card--mobile">
      <section class="phone-column">
       <!-- {% include "_phone_preview.html" %}-->
      </section>
      <section class="status">
        <div class="status-chip"><!--토큰 {{ token }}--></div>
        <p id="status-text" class="status__text"><!--대기 중...--></p>
       <!-- <button id="stop-btn" class="btn btn-primary">공유 중지</button>-->
      </section>
    </main>

    <script>
      const token = '{{ token }}';
      const statusText = document.getElementById('status-text');
      const stopBtn = document.getElementById('stop-btn');
      
      const STORAGE_KEY = `location_share_${token}`;
      const PENDING_LOCATIONS_KEY = `pending_locations_${token}`;

      let watchId = null;
      let isSharing = false;
      let lastLocation = null;
      let locationSendInterval = null;

      // 마지막 위치를 localStorage에 저장
      function saveLastLocation(location) {
        try {
          const locationData = {
            lat: location.latitude,
            lng: location.longitude,
            accuracy: location.accuracy,
            heading: location.heading,
            speed: location.speed,
            timestamp: Date.now(),
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(locationData));
          lastLocation = locationData;
        } catch (error) {
          console.error('위치 저장 오류:', error);
        }
      }

      // 위치를 서버에 전송하는 함수
      async function sendLocation(pos) {
        const { latitude, longitude, accuracy, heading, speed } = pos.coords;
        const locationData = {
          lat: latitude,
          lng: longitude,
          accuracy,
          heading,
          speed,
        };
        
        // localStorage에 마지막 위치 저장
        saveLastLocation(pos.coords);
        
        try {
          // 일반 fetch로 전송 시도
          const response = await fetch(`/api/location/${token}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(locationData),
            keepalive: true, // 페이지가 닫혀도 요청 완료되도록
          });
          
          if (!response.ok) {
            throw new Error('서버 응답 오류');
          }
        } catch (error) {
          console.error('위치 전송 오류:', error);
          // 실패한 위치를 pending에 저장하여 나중에 재전송
          savePendingLocation(locationData);
        }
      }

      // 실패한 위치를 pending에 저장
      function savePendingLocation(locationData) {
        try {
          const pending = JSON.parse(localStorage.getItem(PENDING_LOCATIONS_KEY) || '[]');
          pending.push({
            ...locationData,
            timestamp: Date.now(),
          });
          // 최대 10개만 저장
          if (pending.length > 10) {
            pending.shift();
          }
          localStorage.setItem(PENDING_LOCATIONS_KEY, JSON.stringify(pending));
        } catch (error) {
          console.error('Pending 위치 저장 오류:', error);
        }
      }

      // Pending 위치들을 재전송
      async function retryPendingLocations() {
        try {
          const pending = JSON.parse(localStorage.getItem(PENDING_LOCATIONS_KEY) || '[]');
          if (pending.length === 0) return;
          
          for (const location of pending) {
            try {
              await fetch(`/api/location/${token}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(location),
                keepalive: true,
              });
            } catch (error) {
              console.error('Pending 위치 재전송 실패:', error);
            }
          }
          
          // 성공적으로 전송된 위치들 제거
          localStorage.removeItem(PENDING_LOCATIONS_KEY);
        } catch (error) {
          console.error('Pending 위치 재전송 오류:', error);
        }
      }

      // 위치 공유 시작
      function startSharing() {
        if (isSharing) return;
        isSharing = true;

        if (!('geolocation' in navigator)) {
          if (statusText) {
            statusText.textContent = '이 기기에서 위치 정보를 사용할 수 없습니다.';
          }
          return;
        }

        // Pending 위치들 재전송
        retryPendingLocations();

        // 마지막 위치가 있으면 먼저 전송
        try {
          const savedLocation = localStorage.getItem(STORAGE_KEY);
          if (savedLocation) {
            const location = JSON.parse(savedLocation);
            // 5분 이내의 위치만 재전송
            if (Date.now() - location.timestamp < 300000) {
              sendLocation({ coords: location });
            }
          }
        } catch (error) {
          console.error('저장된 위치 로드 오류:', error);
        }

        watchId = navigator.geolocation.watchPosition(
          async (pos) => {
            await sendLocation(pos);
          },
          (err) => {
            if (statusText) {
              statusText.textContent = `위치 권한 필요: ${err.message}`;
            }
          },
          {
            enableHighAccuracy: true,
            maximumAge: 5000,
            timeout: 15000,
          }
        );

        // 주기적으로 마지막 위치를 서버에 전송 (백그라운드에서도 계속)
        locationSendInterval = setInterval(() => {
          if (lastLocation && isSharing) {
            // 마지막 위치를 주기적으로 재전송하여 위치가 최신 상태 유지
            fetch(`/api/location/${token}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                lat: lastLocation.lat,
                lng: lastLocation.lng,
                accuracy: lastLocation.accuracy,
                heading: lastLocation.heading,
                speed: lastLocation.speed,
              }),
              keepalive: true,
            }).catch(error => {
              console.error('주기적 위치 전송 오류:', error);
            });
          }
        }, 10000); // 10초마다
      }

      // 위치 공유 중지
      function stopSharing() {
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
        }
        if (locationSendInterval) {
          clearInterval(locationSendInterval);
          locationSendInterval = null;
        }
        isSharing = false;
        if (statusText) {
          statusText.textContent = '공유를 중지했습니다.';
        }
        if (stopBtn) {
          stopBtn.disabled = true;
        }
        // localStorage도 정리
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(PENDING_LOCATIONS_KEY);
      }

      // 페이지 로드 시 자동으로 위치 공유 시작
      startSharing();

      // 중지 버튼이 있으면 이벤트 리스너 추가
      if (stopBtn) {
        stopBtn.addEventListener('click', () => {
          stopSharing();
        });
      }

      // 페이지가 백그라운드에 있어도 계속 위치 공유
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && !isSharing) {
          // 페이지가 다시 보이면 위치 공유 재개
          startSharing();
        }
        // 백그라운드에 있어도 watchPosition은 계속 작동함
      });

      // 페이지가 닫히기 전에 마지막 위치를 전송
      window.addEventListener('beforeunload', (event) => {
        if (lastLocation && isSharing) {
          // sendBeacon을 사용하여 페이지가 닫혀도 전송 완료
          const blob = new Blob(
            [JSON.stringify({
              lat: lastLocation.lat,
              lng: lastLocation.lng,
              accuracy: lastLocation.accuracy,
              heading: lastLocation.heading,
              speed: lastLocation.speed,
            })],
            { type: 'application/json' }
          );
          
          // sendBeacon으로 마지막 위치 전송
          if (navigator.sendBeacon) {
            navigator.sendBeacon(`/api/location/${token}`, blob);
          } else {
            // sendBeacon이 지원되지 않으면 fetch with keepalive
            fetch(`/api/location/${token}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                lat: lastLocation.lat,
                lng: lastLocation.lng,
                accuracy: lastLocation.accuracy,
                heading: lastLocation.heading,
                speed: lastLocation.speed,
              }),
              keepalive: true,
            });
          }
        }
        
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
        }
      });

      // 페이지가 포커스를 잃어도 위치 공유는 계속됨
      // (watchPosition은 브라우저가 백그라운드에서도 계속 실행함)
      
      // 페이지가 다시 로드될 때 이전 위치 복원
      window.addEventListener('pageshow', (event) => {
        // 페이지가 백그라운드에서 복원된 경우
        if (event.persisted && isSharing) {
          retryPendingLocations();
        }
      });
    </script>
  </body>
</html>
